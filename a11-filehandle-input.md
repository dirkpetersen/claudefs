# Complete FileHandleManager Implementation for claudefs-meta

## Context
The filehandle.rs module in claudefs-meta crate is partially implemented with only the OpenFlags struct and comprehensive unit tests, but is missing the FileHandle struct and FileHandleManager struct/impl that the tests expect.

## Current State
- OpenFlags implemented (64 lines, complete)
- 11 unit tests defined but fail because FileHandle and FileHandleManager don't exist
- lib.rs exports: `pub use filehandle::{FileHandle, FileHandleManager, OpenFlags};`

## Required Implementation

### FileHandle Struct
A data structure representing an open file descriptor with these properties:
- `fh: u64` — unique file handle ID (generated by FileHandleManager)
- `ino: InodeId` — the inode being accessed
- `client: NodeId` — which client node opened this handle
- `flags: OpenFlags` — open mode flags (READ, WRITE, APPEND, etc.)
- Fields should be `pub` for test access
- Must be `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`

### FileHandleManager Struct
A thread-safe manager tracking all open file handles across the cluster.

**Fields:**
- `next_fh: AtomicU64` — monotonic counter for next file handle ID (starts at 1)
- `handles: Arc<RwLock<HashMap<u64, FileHandle>>>` — by file handle ID
- `inode_handles: Arc<RwLock<HashMap<InodeId, Vec<u64>>>>` — which handles are open for each inode
- `client_handles: Arc<RwLock<HashMap<NodeId, Vec<u64>>>>` — which handles are open per client

**Methods:**

#### `fn new() -> Self`
Create a new FileHandleManager. next_fh starts at 1, maps are empty.

#### `fn open(&self, ino: InodeId, client: NodeId, flags: OpenFlags) -> u64`
Open a new file handle. Returns the generated file handle ID (u64).
- Atomically increment next_fh to get a unique ID
- Create FileHandle with the inode, client, flags
- Add to handles map (by fh ID)
- Add to inode_handles map (maps ino -> vec of fh IDs)
- Add to client_handles map (maps client -> vec of fh IDs)

#### `fn close(&self, fh: u64) -> Result<FileHandle, MetaError>`
Close and remove a file handle.
- Lookup fh in handles map
- If not found, return MetaError::HandleNotFound or similar
- On success: remove from all three maps, return the FileHandle
- Uses MetaError enum from types.rs (add a variant if needed)

#### `fn get(&self, fh: u64) -> Option<FileHandle>`
Look up and return a FileHandle by ID (non-destructive). Return clone of the handle or None.

#### `fn is_open(&self, ino: InodeId) -> bool`
Check if any handle is open for the inode. Return true if inode_handles contains ino and its vec is not empty.

#### `fn is_open_for_write(&self, ino: InodeId) -> bool`
Check if any write handle is open for the inode.
- Look up inode in inode_handles
- For each fh in that vec, get the FileHandle
- If any has flags.is_writable(), return true
- Otherwise false

#### `fn handles_for_inode(&self, ino: InodeId) -> Vec<FileHandle>`
Return all open FileHandles for an inode (read lock, clone and collect).

#### `fn handles_for_client(&self, client: NodeId) -> Vec<FileHandle>`
Return all open FileHandles for a client (read lock, clone and collect).

#### `fn close_all_for_client(&self, client: NodeId) -> Vec<FileHandle>`
Close all handles for a client (e.g., on client disconnect). Returns the closed handles.
- Look up client in client_handles
- For each fh in that vec, call close(fh) internally
- Return all closed handles
- Cleanup the client from client_handles

#### `fn open_count(&self) -> usize`
Return total number of open handles (read lock on handles map, return len).

## Implementation Notes

1. **Thread Safety:** Use `Arc<RwLock<...>>` for shared state across threads. RwLock allows multiple readers or one writer.
2. **Error Handling:** Use `MetaError` from types.rs. May need to add a new variant like `HandleNotFound` if it doesn't exist.
3. **ID Generation:** Use `AtomicU64` with `fetch_add(1, Ordering::SeqCst)` for monotonic IDs.
4. **Cloning:** FileHandle must derive `Clone` so it can be returned from methods.
5. **Imports:** Use existing imports: `serde`, `std::collections::HashMap`, `std::sync::*`, `crate::types::*`

## Test Expectations

The 11 tests expect the above behavior:
1. test_open_and_close: open, get fh, close, verify handle returned
2. test_get_handle: open, get, verify fields match
3. test_is_open: open makes is_open true, close makes false
4. test_is_open_for_write: distinguish read-only vs writable
5. test_handles_for_inode: return vec of all handles for inode
6. test_handles_for_client: return vec of all handles for client
7. test_close_all_for_client: close all handles for a client
8. test_open_count: track total open count correctly
9. test_close_nonexistent: return error on close of nonexistent handle
10. test_multiple_opens_same_inode: multiple clients can open same inode

## Rust Idioms
- Derive `Default` via thiserror for FileHandleManager (impl already at line 54)
- Use `clone()` to return snapshots of FileHandles from read-locked maps
- Write lock only when modifying state (open, close, close_all_for_client)
- Read lock for queries (is_open, is_open_for_write, get, handles_for_*, open_count)
