//! Penetration test concepts for A8 management API.
//!
//! Findings: FINDING-27 through FINDING-30

use claudefs_mgmt::{AdminApi, MgmtConfig, ClusterMetrics};
use axum::body::Body;
use axum::http::{Request, StatusCode};
use std::sync::Arc;
use tower::ServiceExt;

fn make_api(token: Option<&str>) -> axum::Router {
    let mut config = MgmtConfig::default();
    config.admin_token = token.map(|t| t.to_string());
    let config = Arc::new(config);
    let metrics = Arc::new(ClusterMetrics::new());
    let api = Arc::new(AdminApi::new(metrics, config));
    api.router()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn finding_27_path_traversal_in_node_id() {
        let router = make_api(None);

        let payloads = [
            "/api/v1/nodes/node%00injected",
            "/api/v1/nodes/node%2e%2e",
        ];

        for path in payloads {
            let request = Request::builder()
                .uri(path)
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await.unwrap();
            assert_ne!(
                response.status(),
                StatusCode::OK,
                "FINDING-27: Path '{}' should not return 200",
                path
            );
        }
    }

    #[tokio::test]
    async fn finding_28_oversized_request_body() {
        let router = make_api(None);

        let large_json = "x".repeat(1024 * 1024);
        let request = Request::builder()
            .method("POST")
            .uri("/api/v1/nodes/node-1/drain")
            .header("Content-Type", "application/json")
            .body(Body::from(large_json))
            .unwrap();
        let response = router.oneshot(request).await.unwrap();
        assert!(
            true,
            "FINDING-28: No body size limit enforced by middleware"
        );
    }

    #[tokio::test]
    async fn finding_29_missing_security_headers() {
        let router = make_api(None);

        let request = Request::builder()
            .uri("/health")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();

        let headers = response.headers();

        assert!(
            headers.get("x-content-type-options").is_none(),
            "FINDING-29: X-Content-Type-Options header missing"
        );
        assert!(
            headers.get("x-frame-options").is_none(),
            "FINDING-29: X-Frame-Options header missing"
        );
        assert!(
            headers.get("strict-transport-security").is_none(),
            "FINDING-29: Strict-Transport-Security header missing"
        );
        assert!(
            headers.get("x-xss-protection").is_none(),
            "FINDING-29: X-XSS-Protection header missing"
        );
    }

    #[tokio::test]
    async fn finding_30_no_cors_restriction() {
        let router = make_api(None);

        let request = Request::builder()
            .method("OPTIONS")
            .uri("/api/v1/nodes")
            .header("Origin", "http://attacker.example.com")
            .header("Access-Control-Request-Method", "GET")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();

        let headers = response.headers();
        assert!(
            headers.get("access-control-allow-origin").is_none(),
            "FINDING-30: No CORS policy configured â€” any origin could access API"
        );
    }

    #[tokio::test]
    async fn url_encoding_bypass_attempts() {
        let router = make_api(None);

        let encoded_paths = ["/health%00admin", "/%68%65%61%6c%74%68"];

        for path in encoded_paths {
            let request = Request::builder()
                .uri(path)
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await;
            if let Ok(resp) = response {
                assert!(
                    resp.status() == StatusCode::OK || resp.status() == StatusCode::NOT_FOUND,
                    "Encoded path '{}' returned unexpected status: {}",
                    path,
                    resp.status()
                );
            }
        }
    }

    #[tokio::test]
    async fn http_method_confusion() {
        let router = make_api(None);

        let methods = ["DELETE", "PATCH", "PUT"];
        for method in methods {
            let request = Request::builder()
                .method(method)
                .uri("/health")
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await.unwrap();
            assert_ne!(
                response.status(),
                StatusCode::OK,
                "Method {} on /health should not return 200",
                method
            );
        }
    }

    #[tokio::test]
    async fn large_header_values() {
        let router = make_api(None);

        let large_header = "x".repeat(8192);
        let request = Request::builder()
            .uri("/health")
            .header("X-Custom-Header", large_header.as_str())
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();
        assert!(
            response.status() == StatusCode::OK
                || response.status() == StatusCode::REQUEST_HEADER_FIELDS_TOO_LARGE,
            "Large header handled gracefully"
        );
    }

    #[tokio::test]
    async fn host_header_injection() {
        let router = make_api(None);

        let request = Request::builder()
            .uri("/health")
            .header("Host", "evil.example.com")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();
        assert_eq!(
            response.status(),
            StatusCode::OK,
            "Host header doesn't affect routing"
        );
    }

    #[tokio::test]
    async fn api_endpoint_discovery() {
        let router = make_api(None);

        let hidden_paths = [
            "/admin",
            "/debug",
            "/env",
            "/config",
            "/.env",
            "/api/internal",
            "/api/v1/admin/secret",
        ];

        for path in hidden_paths {
            let request = Request::builder()
                .uri(path)
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await.unwrap();
            assert_eq!(
                response.status(),
                StatusCode::NOT_FOUND,
                "Path '{}' should return 404",
                path
            );
        }
    }

    #[tokio::test]
    async fn metrics_endpoint_info_leakage() {
        let router = make_api(None);

        let request = Request::builder()
            .uri("/metrics")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::OK);

        let body = axum::body::to_bytes(response.into_body(), 1024 * 1024)
            .await
            .unwrap();
        let body_str = String::from_utf8_lossy(&body);

        assert!(
            !body_str.contains("password"),
            "Metrics should not contain passwords"
        );
        assert!(
            !body_str.contains("secret"),
            "Metrics should not contain secrets"
        );
        assert!(
            !body_str.contains("token"),
            "Metrics should not contain tokens"
        );
    }

    #[tokio::test]
    async fn multiple_auth_headers() {
        let router = make_api(Some("correct-token"));

        let request = Request::builder()
            .uri("/api/v1/nodes")
            .header("Authorization", "Bearer wrong-token")
            .header("Authorization", "Bearer correct-token")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await;
        assert!(response.is_ok(), "Multiple auth headers handled without panic");
    }

    #[tokio::test]
    async fn empty_bearer_token() {
        let router = make_api(Some("secret"));

        let request = Request::builder()
            .uri("/api/v1/nodes")
            .header("Authorization", "Bearer ")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();
        assert_eq!(
            response.status(),
            StatusCode::UNAUTHORIZED,
            "Empty bearer token should be rejected"
        );
    }

    #[tokio::test]
    async fn bearer_with_special_chars() {
        let router = make_api(Some("secret"));

        let payloads = ["Bearer secret\n", "Bearer secret\r\n"];

        for payload in payloads {
            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", payload)
                .body(Body::empty());
            if let Ok(req) = request {
                let response = router.clone().oneshot(req).await.unwrap();
                assert_eq!(
                    response.status(),
                    StatusCode::UNAUTHORIZED,
                    "Special chars in bearer should be rejected"
                );
            }
        }
    }

    #[tokio::test]
    async fn invalid_token_rejected() {
        let router = make_api(Some("secret-token"));

        let request = Request::builder()
            .uri("/api/v1/nodes")
            .header("Authorization", "Bearer wrong-token")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
    }

    #[tokio::test]
    async fn health_endpoint_no_auth_required() {
        let router = make_api(None);

        let request = Request::builder()
            .uri("/health")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn health_endpoint_with_auth_works() {
        let router = make_api(Some("secret"));

        let request = Request::builder()
            .uri("/health")
            .header("Authorization", "Bearer secret")
            .body(Body::empty())
            .unwrap();
        let response = router.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::OK);
    }
}