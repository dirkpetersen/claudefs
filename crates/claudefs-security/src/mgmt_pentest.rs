//! Phase 3 full penetration test of A8 management API.
//!
//! Findings: FINDING-31 through FINDING-42
//!
//! This module tests the AdminApi for common security vulnerabilities
//! including rate limiting bypass, RBAC gaps, information disclosure,
//! and injection attacks.

use axum::body::Body;
use axum::http::{header, Method, Request, StatusCode};
use claudefs_mgmt::{
    rbac::{admin_role, operator_role, tenant_admin_role, viewer_role, Permission, RbacRegistry, User},
    security::{constant_time_eq, AuthRateLimiter},
    AdminApi, ClusterMetrics, MgmtConfig,
};
use std::sync::Arc;
use tower::ServiceExt;

fn make_api(token: Option<&str>) -> axum::Router {
    let mut config = MgmtConfig::default();
    config.admin_token = token.map(|t| t.to_string());
    let config = Arc::new(config);
    let metrics = Arc::new(ClusterMetrics::new());
    let api = Arc::new(AdminApi::new(metrics, config));
    api.router()
}

#[cfg(test)]
mod tests {
    use super::*;

    mod group1_rate_limiter_bypass {
        use super::*;

        #[tokio::test]
        async fn finding_31_x_forwarded_for_spoofing_bypasses_per_ip_limit() {
            let router = make_api(Some("secret-token"));
            let base_ip = "10.0.0.1";

            for i in 0..5 {
                let request = Request::builder()
                    .uri("/api/v1/nodes")
                    .header("Authorization", "Bearer wrong-token")
                    .header("x-forwarded-for", base_ip)
                    .body(Body::empty())
                    .unwrap();
                let response = router.clone().oneshot(request).await.unwrap();
                assert_eq!(response.status(), StatusCode::UNAUTHORIZED, "FINDING-31: Request {} should fail", i + 1);
            }

            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", "Bearer wrong-token")
                .header("x-forwarded-for", base_ip)
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await.unwrap();
            assert_eq!(response.status(), StatusCode::TOO_MANY_REQUESTS, "FINDING-31: 6th request should be rate limited for base IP");

            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", "Bearer wrong-token")
                .header("x-forwarded-for", "10.0.0.2")
                .body(Body::empty())
                .unwrap();
            let response = router.oneshot(request).await.unwrap();
            assert_eq!(response.status(), StatusCode::UNAUTHORIZED, "FINDING-31: Different X-Forwarded-For should bypass rate limit - IP-based limiting trusts client header");
        }

        #[tokio::test]
        async fn finding_32_rate_limiter_window_reset_timing() {
            let router = make_api(Some("secret-token"));
            let test_ip = "192.168.1.100";

            for i in 0..4 {
                let request = Request::builder()
                    .uri("/api/v1/nodes")
                    .header("Authorization", "Bearer wrong-token")
                    .header("x-forwarded-for", test_ip)
                    .body(Body::empty())
                    .unwrap();
                let response = router.clone().oneshot(request).await.unwrap();
                assert_eq!(response.status(), StatusCode::UNAUTHORIZED, "FINDING-32: Request {} should fail", i + 1);
            }

            std::thread::sleep(std::time::Duration::from_millis(50));

            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", "Bearer wrong-token")
                .header("x-forwarded-for", test_ip)
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await.unwrap();
            assert_eq!(response.status(), StatusCode::UNAUTHORIZED, "FINDING-32: 5th request should fail before window expiry");

            std::thread::sleep(std::time::Duration::from_millis(100));

            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", "Bearer wrong-token")
                .header("x-forwarded-for", test_ip)
                .body(Body::empty())
                .unwrap();
            let response = router.oneshot(request).await.unwrap();
            assert_eq!(response.status(), StatusCode::UNAUTHORIZED, "FINDING-32: After window expiry at 60s, rate limit should reset - testing actual reset requires 60s wait");
        }

        #[tokio::test]
        async fn finding_33_concurrent_auth_failures_race_condition() {
            let router = make_api(Some("secret-token"));
            let test_ip = "10.10.10.10";

            let mut handles = Vec::new();
            for _ in 0..10 {
                let router_clone = router.clone();
                let handle = std::thread::spawn(move || {
                    let rt = tokio::runtime::Runtime::new().unwrap();
                    rt.block_on(async {
                        let request = Request::builder()
                            .uri("/api/v1/nodes")
                            .header("Authorization", "Bearer wrong-token")
                            .header("x-forwarded-for", test_ip)
                            .body(Body::empty())
                            .unwrap();
                        router_clone.oneshot(request).await.unwrap()
                    })
                });
                handles.push(handle);
            }

            let mut unauthenticated_count = 0;
            let mut rate_limited_count = 0;
            for handle in handles {
                let response = handle.join().unwrap();
                match response.status() {
                    StatusCode::UNAUTHORIZED => unauthenticated_count += 1,
                    StatusCode::TOO_MANY_REQUESTS => rate_limited_count += 1,
                    _ => {}
                }
            }

            assert!(unauthenticated_count + rate_limited_count == 10, "FINDING-33: All 10 concurrent requests should receive response");
            assert!(rate_limited_count >= 1, "FINDING-33: Rate limiter should catch some concurrent requests, but race conditions may allow bypass");
        }
    }

    mod group2_rbac_privilege_escalation {
        use super::*;

        #[tokio::test]
        async fn finding_34_rbac_not_integrated_in_routing() {
            let router = make_api(Some("secret-token"));

            let request = Request::builder()
                .uri("/api/v1/nodes/node1/drain")
                .method(Method::POST)
                .header("Authorization", "Bearer secret-token")
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await.unwrap();

            assert_eq!(response.status(), StatusCode::OK, "FINDING-34: With valid token, drain endpoint accepts request");

            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", "Bearer secret-token")
                .body(Body::empty())
                .unwrap();
            let response = router.oneshot(request).await.unwrap();
            assert_eq!(response.status(), StatusCode::OK, "FINDING-34: Same token can access nodes list");

            let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
            let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
            assert!(json.is_array(), "FINDING-34: No RBAC role enforcement - the API treats all valid Bearer tokens as admin");
        }

        #[tokio::test]
        async fn finding_35_role_aggregation_combined_permissions() {
            let mut registry = RbacRegistry::new()
                .with_builtin_roles();

            let mut user = User::new("user1".to_string(), "alice".to_string());
            user.roles.push("viewer".to_string());
            user.roles.push("tenant_admin".to_string());
            registry.add_user(user);

            let viewer_perms = registry.user_permissions("user1");
            let viewer_role_perms = registry.get_role("viewer").unwrap().permissions.clone();
            let tenant_admin_perms = registry.get_role("tenant_admin").unwrap().permissions.clone();

            let combined_expected: Vec<_> = viewer_role_perms.union(&tenant_admin_perms).collect();

            assert!(viewer_perms.contains(&Permission::ViewCluster), "FINDING-35: User should have ViewCluster from viewer role");
            assert!(viewer_perms.contains(&Permission::ViewNodes), "FINDING-35: User should have ViewNodes from viewer role");
            assert!(viewer_perms.contains(&Permission::ManageQuotas), "FINDING-35: User should have ManageQuotas from tenant_admin role");
            assert!(viewer_perms.contains(&Permission::ManageSnapshots), "FINDING-35: User should have ManageSnapshots from tenant_admin role");
            assert_eq!(viewer_perms.len(), combined_expected.len(), "FINDING-35: RBAC aggregates permissions from all assigned roles correctly");
        }

        #[tokio::test]
        async fn finding_36_role_removal_does_not_invalidate_cached_permissions() {
            let mut registry = RbacRegistry::new()
                .with_builtin_roles();

            let mut user = User::new("user1".to_string(), "alice".to_string());
            user.roles.push("viewer".to_string());
            registry.add_user(user);

            let initial_perms = registry.user_permissions("user1");
            assert!(initial_perms.contains(&Permission::ViewCluster), "FINDING-36: Initial permissions include ViewCluster");

            let initial_perm_count = initial_perms.len();

            registry.revoke_role("user1", "viewer").unwrap();

            let after_revoke = registry.user_permissions("user1");
            assert!(after_revoke.is_empty(), "FINDING-36: After revoking role, user_permissions returns fresh result - no caching issue here");
            assert!(after_revoke.len() < initial_perm_count, "FINDING-36: Permission count decreased after role removal");
        }
    }

    mod group3_information_disclosure {
        use super::*;

        #[tokio::test]
        async fn finding_37_metrics_endpoint_sensitive_config_leak() {
            let router = make_api(Some("secret-token"));

            let mut config = MgmtConfig::default();
            config.admin_token = Some("super-secret-admin-token-12345".to_string());
            let config = Arc::new(config);
            let metrics = Arc::new(ClusterMetrics::new());
            let api = Arc::new(AdminApi::new(metrics, config));
            let router_with_secrets = api.router();

            let request = Request::builder()
                .uri("/metrics")
                .body(Body::empty())
                .unwrap();
            let response = router_with_secrets.oneshot(request).await.unwrap();

            assert_eq!(response.status(), StatusCode::OK, "FINDING-37: Metrics endpoint should be accessible");

            let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
            let output = String::from_utf8_lossy(&body);

            assert!(!output.contains("super-secret-admin-token"), "FINDING-37: Admin token should not appear in Prometheus metrics output");
            assert!(!output.contains("secret"), "FINDING-37: Metrics should not leak sensitive config values");
        }

        #[tokio::test]
        async fn finding_38_error_responses_internal_paths_stack_trace() {
            let router = make_api(Some("secret-token"));

            let request = Request::builder()
                .uri("/api/v1/nodes/nonexistent-node-12345/drain")
                .method(Method::POST)
                .header("Authorization", "Bearer secret-token")
                .body(Body::empty())
                .unwrap();
            let response = router.oneshot(request).await.unwrap();

            let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
            let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

            let response_text = serde_json::to_string(&json).unwrap();

            assert!(!response_text.contains("/home/"), "FINDING-38: Error should not expose internal file paths");
            assert!(!response_text.contains("stack"), "FINDING-38: Error should not expose stack traces");
            assert!(!response_text.contains("crate:"), "FINDING-38: Error should not expose Rust crate names");
            assert!(json.get("node_id").is_some(), "FINDING-38: Error response contains safe node_id field");
        }

        #[tokio::test]
        async fn finding_39_cluster_topology_internal_addresses() {
            let router = make_api(Some("secret-token"));

            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", "Bearer secret-token")
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await.unwrap();

            let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
            let json: Vec<serde_json::Value> = serde_json::from_slice(&body).unwrap();

            assert!(json.is_empty(), "FINDING-39: Empty cluster has no nodes to leak addresses");

            let mut config = MgmtConfig::default();
            config.admin_token = Some("secret-token".to_string());
            let config = Arc::new(config);
            let metrics = Arc::new(ClusterMetrics::new());
            let api = Arc::new(AdminApi::new(metrics, config));

            use claudefs_mgmt::api::NodeRegistry;
            use claudefs_mgmt::api::{NodeInfo, NodeStatus};

            let mut registry = NodeRegistry::new();
            registry.add_node(NodeInfo {
                node_id: "node-1".to_string(),
                addr: "192.168.1.100:9000".to_string(),
                status: NodeStatus::Healthy,
                capacity_total: 1000000000,
                capacity_used: 500000000,
                last_seen: 1234567890,
            });
            registry.add_node(NodeInfo {
                node_id: "node-2".to_string(),
                addr: "10.0.0.50:9000".to_string(),
                status: NodeStatus::Healthy,
                capacity_total: 1000000000,
                capacity_used: 300000000,
                last_seen: 1234567890,
            });

            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", "Bearer secret-token")
                .body(Body::empty())
                .unwrap();
            let response = router.oneshot(request).await.unwrap();

            let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
            let json: Vec<serde_json::Value> = serde_json::from_slice(&body).unwrap();

            for node in &json {
                if let Some(addr) = node.get("addr").and_then(|v| v.as_str()) {
                    let is_internal = addr.starts_with("192.168.") || addr.starts_with("10.") || addr.starts_with("172.");
                    assert!(is_internal, "FINDING-39: Node addresses in /api/v1/nodes expose internal network addresses - this may be acceptable but reveals topology");
                }
            }
        }
    }

    mod group4_request_smuggling_injection {
        use super::*;

        #[tokio::test]
        async fn finding_40_node_id_parameter_injection_drain() {
            let router = make_api(Some("secret-token"));

            let malicious_ids = vec![
                "node1'; DROP TABLE nodes;--",
                "node1\" OR \"1\"=\"1",
                "node1 && cat /etc/passwd",
                "../../../etc/passwd",
                "node1$(whoami)",
                "node1`id`",
            ];

            for malicious_id in malicious_ids {
                let uri = format!("/api/v1/nodes/{}/drain", urlencoding::encode(malicious_id));
                let request = Request::builder()
                    .uri(&uri)
                    .method(Method::POST)
                    .header("Authorization", "Bearer secret-token")
                    .body(Body::empty())
                    .unwrap();
                let response = router.clone().oneshot(request).await.unwrap();

                let status = response.status();
                let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
                let text = String::from_utf8_lossy(&body);

                assert!(status == StatusCode::OK || status == StatusCode::NOT_FOUND, "FINDING-40: Injection attempts should either succeed (node not found) or fail gracefully - no SQL/command execution observed");
                assert!(!text.contains("error") || text.contains("not found"), "FINDING-40: Error messages should not reveal injection success");
            }
        }

        #[tokio::test]
        async fn finding_41_content_type_confusion_json_endpoint() {
            let router = make_api(Some("secret-token"));

            let malicious_body = r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/hostname">
]>
<data>&xxe;</data>"#;

            let request = Request::builder()
                .uri("/api/v1/nodes")
                .header("Authorization", "Bearer secret-token")
                .header("Content-Type", "application/xml")
                .body(Body::from(malicious_body.to_string()))
                .unwrap();
            let response = router.oneshot(request).await.unwrap();

            let status = response.status();
            assert!(status == StatusCode::OK || status == StatusCode::BAD_REQUEST || status == StatusCode::UNSUPPORTED_MEDIA_TYPE,
                "FINDING-41: XML Content-Type to JSON endpoint should be rejected or handled safely");

            let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
            let text = String::from_utf8_lossy(&body);

            assert!(!text.contains("root:"), "FINDING-41: XXE injection should not expose file contents");
        }

        #[tokio::test]
        async fn finding_42_http_verb_tunneling_x_http_method_override() {
            let router = make_api(Some("secret-token"));

            let request = Request::builder()
                .uri("/api/v1/nodes/node1/drain")
                .header("Authorization", "Bearer secret-token")
                .header("X-HTTP-Method-Override", "DELETE")
                .body(Body::empty())
                .unwrap();
            let response = router.clone().oneshot(request).await.unwrap();

            let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
            let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

            assert!(json.get("status").is_some(), "FINDING-42: X-HTTP-Method-Override with DELETE should execute drain (POST) handler - verb tunneling may allow bypassing method restrictions");
        }
    }

    mod group5_constant_time_comparison {
        use super::*;

        #[test]
        fn finding_43_constant_time_eq_equal_strings() {
            let result = constant_time_eq("secret-token-12345", "secret-token-12345");
            assert!(result, "FINDING-43: constant_time_eq should return true for identical strings");
        }

        #[test]
        fn finding_44_constant_time_eq_different_strings() {
            let result = constant_time_eq("secret-token-12345", "secret-token-67890");
            assert!(!result, "FINDING-44: constant_time_eq should return false for different strings of same length");
        }

        #[test]
        fn finding_45_constant_time_eq_different_lengths() {
            let result = constant_time_eq("short", "much-longer-string");
            assert!(!result, "FINDING-45: constant_time_eq should return false for different length strings (early reject)");
        }

        #[test]
        fn finding_46_constant_time_eq_empty_vs_nonempty() {
            let result_empty = constant_time_eq("", "");
            assert!(result_empty, "FINDING-46: Empty strings should be equal");

            let result_empty_vs_char = constant_time_eq("", "a");
            assert!(!result_empty_vs_char, "FINDING-46: Empty vs non-empty should return false");

            let result_char_vs_empty = constant_time_eq("a", "");
            assert!(!result_char_vs_empty, "FINDING-46: Non-empty vs empty should return false");
        }

        #[test]
        fn finding_47_constant_time_eq_security_property() {
            let token = "correct-token";
            let variations = vec![
                "correct-tokena",
                "correct-tokeN",
                "correct-token ",
                " correct-token",
                "xorrect-token",
            ];

            for wrong in variations {
                let result = constant_time_eq(token, wrong);
                assert!(!result, "FINDING-47: constant_time_eq should reject similar but wrong tokens");
            }

            assert!(constant_time_eq(token, token), "FINDING-47: constant_time_eq should accept correct token");
        }
    }
}