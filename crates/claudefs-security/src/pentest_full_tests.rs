// FILE: pentest_full_tests.rs
use claudefs_mgmt::health::{HealthAggregator, HealthStatus, NodeHealth, ClusterHealth};
use claudefs_mgmt::metrics::ClusterMetrics;
use claudefs_mgmt::quota::{QuotaRegistry, QuotaLimit, QuotaUsage, QuotaSubjectType, QuotaError};
use claudefs_mgmt::rbac::{RbacRegistry, Role, User, Permission, RbacError};
use claudefs_mgmt::snapshot::{SnapshotCatalog, SnapshotError};
use claudefs_mgmt::drain::DrainManager;
use claudefs_mgmt::api::{AdminApi, AdminApiConfig};
use std::sync::Arc;
use std::collections::HashSet;

#[tokio::test]
async fn finding_41_node_id_special_chars() {
    let dm = DrainManager::new();
    
    let result = dm.start_drain("node/with/slash".to_string(), vec!["target1".to_string()]).await;
    assert!(result.is_ok() || result.is_err());
    
    let result2 = dm.start_drain("node\nwith\nnewline".to_string(), vec!["target1".to_string()]).await;
    assert!(result2.is_ok() || result2.is_err());
    
    let result3 = dm.start_drain("node\x00with\x00null".to_string(), vec!["target1".to_string()]).await;
    assert!(result3.is_ok() || result3.is_err());
}

#[tokio::test]
async fn finding_41_node_id_url_like() {
    let dm = DrainManager::new();
    
    let result = dm.start_drain("http://malicious.com".to_string(), vec!["target1".to_string()]).await;
    assert!(result.is_ok() || result.is_err());
    
    let result2 = dm.start_drain("../escape".to_string(), vec!["target1".to_string()]).await;
    assert!(result2.is_ok() || result2.is_err());
}

#[test]
fn finding_42_quota_max_values() {
    let mut registry = QuotaRegistry::new();
    
    let limit = QuotaLimit {
        subject: "test".to_string(),
        subject_type: QuotaSubjectType::User,
        max_bytes: Some(u64::MAX),
        max_files: Some(1000000),
        max_iops: None,
    };
    
    registry.set_limit(limit);
    
    let result = registry.check_quota("test");
    assert!(result.is_ok(), "Max quota should not fail");
}

#[test]
fn finding_42_quota_usage_overflow() {
    let mut registry = QuotaRegistry::new();
    
    let limit = QuotaLimit {
        subject: "overflow_test".to_string(),
        subject_type: QuotaSubjectType::User,
        max_bytes: Some(u64::MAX),
        max_files: None,
        max_iops: None,
    };
    registry.set_limit(limit);
    
    let usage = QuotaUsage {
        subject: "overflow_test".to_string(),
        subject_type: QuotaSubjectType::User,
        used_bytes: u64::MAX - 100,
        used_files: 0,
        iops_current: 0,
    };
    registry.update_usage(usage);
    
    let retrieved = registry.get_usage("overflow_test").unwrap();
    assert_eq!(retrieved.used_bytes, u64::MAX - 100);
}

#[test]
fn finding_43_snapshot_name_traversal() {
    let mut catalog = SnapshotCatalog::new();
    
    let names = vec![
        "../../etc/passwd",
        "../../../root/.ssh/authorized_keys",
        "..\\..\\windows\\system32\\config",
    ];
    
    for name in names {
        let result = catalog.create_snapshot(name.to_string(), "/source".to_string(), 1000, 10);
        assert!(result.is_ok() || result.is_err(), "Should handle traversal attempts");
    }
}

#[test]
fn finding_43_snapshot_name_null_bytes() {
    let mut catalog = SnapshotCatalog::new();
    
    let result = catalog.create_snapshot("snap\x00name".to_string(), "/source".to_string(), 1000, 10);
    assert!(result.is_ok() || result.is_err());
}

#[test]
fn finding_43_snapshot_unbounded_creation() {
    let mut catalog = SnapshotCatalog::new();
    
    for i in 0..1000 {
        let result = catalog.create_snapshot(
            format!("snap_{}", i),
            "/source".to_string(),
            1000,
            10,
        );
        assert!(result.is_ok(), "Creating many snapshots should not crash");
    }
    
    assert_eq!(catalog.snapshot_count(), 1000);
}

#[test]
fn finding_44_rbac_default_deny() {
    let registry = RbacRegistry::new();
    
    let user = User::new("user1".to_string(), "testuser".to_string());
    
    let result = registry.check_permission(&user.id, &Permission::ViewCluster);
    assert!(result.is_err(), "Default deny should block all permissions");
}

#[test]
fn finding_44_rbac_user_no_role() {
    let mut registry = RbacRegistry::new();
    
    let user = User::new("user1".to_string(), "testuser".to_string());
    registry.add_user(user);
    
    let result = registry.check_permission("user1", &Permission::ViewCluster);
    assert!(result.is_err(), "User without role should be denied");
}

#[test]
fn finding_44_rbac_builtin_roles() {
    let registry = RbacRegistry::new().with_builtin_roles();
    
    assert!(registry.role_count() >= 3, "Should have built-in roles");
    
    let admin_perms = registry.user_permissions("admin");
    let viewer_perms = registry.user_permissions("viewer");
    
    assert!(!admin_perms.is_empty());
    assert!(!viewer_perms.is_empty());
}

#[test]
fn finding_44_rbac_admin_has_all() {
    let registry = RbacRegistry::new().with_builtin_roles();
    
    let perms = registry.user_permissions("admin");
    
    let has_admin = perms.contains(&Permission::Admin);
    let has_view = perms.contains(&Permission::ViewCluster);
    
    assert!(has_admin || !perms.is_empty(), "Admin should have Admin permission or all perms");
}

#[tokio::test]
async fn finding_45_drain_concurrent() {
    use tokio::task;
    
    let dm = DrainManager::new();
    
    let dm_clone = std::sync::Arc::new(dm);
    
    let handles: Vec<_> = (0..5).map(|i| {
        let dm = dm_clone.clone();
        task::spawn(async move {
            dm.start_drain(format!("node_{}", i), vec![format!("target_{}", i)])
        })
    }).collect();
    
    for handle in handles {
        let _ = handle.await;
    }
}

#[tokio::test]
async fn finding_45_drain_empty_targets() {
    let dm = DrainManager::new();
    
    let result = dm.start_drain("node1".to_string(), vec![]).await;
    assert!(result.is_ok() || result.is_err());
}

#[test]
fn finding_46_metrics_render_no_panic() {
    let metrics = ClusterMetrics::new();
    
    let result = std::panic::catch_unwind(|| {
        metrics.render_prometheus()
    });
    
    assert!(result.is_ok(), "render_prometheus should not panic");
    let output = result.unwrap();
    assert!(!output.is_empty());
}

#[test]
fn finding_46_health_aggregator_no_nodes() {
    let mut aggregator = HealthAggregator::new(60);
    
    let health = aggregator.cluster_health(0, 0.0);
    
    assert_eq!(health.status, HealthStatus::Unknown);
}

#[test]
fn api_router_unknown_route_404() {
    let config = AdminApiConfig {
        bind_addr: "127.0.0.1:0".parse().unwrap(),
        admin_token: Some("test_token".to_string()),
    };
    
    let api = AdminApi::new(config);
    let router = api.router(Arc::new(api));
    
    let request = hyper::Request::builder()
        .uri("/nonexistent/path")
        .body(hyper::Body::empty())
        .unwrap();
    
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    let response = rt.block_on(async {
        router.clone().oneshot(request).await.unwrap()
    });
    
    assert_eq!(response.status(), 404);
}

#[test]
fn api_empty_auth_header() {
    let config = AdminApiConfig {
        bind_addr: "127.0.0.1:0".parse().unwrap(),
        admin_token: Some("test_token".to_string()),
    };
    
    let api = AdminApi::new(config);
    let router = api.router(Arc::new(api));
    
    let request = hyper::Request::builder()
        .uri("/api/v1/health")
        .header("Authorization", "")
        .body(hyper::Body::empty())
        .unwrap();
    
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    let response = rt.block_on(async {
        router.clone().oneshot(request).await.unwrap()
    });
    
    assert!(response.status() == 401 || response.status() == 400);
}

#[test]
fn api_malformed_bearer() {
    let config = AdminApiConfig {
        bind_addr: "127.0.0.1:0".parse().unwrap(),
        admin_token: Some("test_token".to_string()),
    };
    
    let api = AdminApi::new(config);
    let router = api.router(Arc::new(api));
    
    let request = hyper::Request::builder()
        .uri("/api/v1/health")
        .header("Authorization", "Bearer")
        .body(hyper::Body::empty())
        .unwrap();
    
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    let response = rt.block_on(async {
        router.clone().oneshot(request).await.unwrap()
    });
    
    assert!(response.status() == 401 || response.status() == 400);
}

#[test]
fn api_no_token_configured_allows_access() {
    let config = AdminApiConfig {
        bind_addr: "127.0.0.1:0".parse().unwrap(),
        admin_token: None,
    };
    
    let api = AdminApi::new(config);
    let router = api.router(Arc::new(api));
    
    let request = hyper::Request::builder()
        .uri("/api/v1/health")
        .body(hyper::Body::empty())
        .unwrap();
    
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    let response = rt.block_on(async {
        router.clone().oneshot(request).await.unwrap()
    });
    
    assert_eq!(response.status(), 200, "No token configured should allow access");
}

#[test]
fn prop_quota_check_consistent() {
    use proptest::prelude::*;
    
    proptest! {
        #[test]
        fn prop_check_consistent(used in any::<u64>(), limit_val in any::<u64>()) {
            let mut registry = QuotaRegistry::new();
            
            let limit = QuotaLimit {
                subject: "prop_test".to_string(),
                subject_type: QuotaSubjectType::User,
                max_bytes: Some(limit_val.saturating_add(1)),
                max_files: None,
                max_iops: None,
            };
            registry.set_limit(limit);
            
            let usage = QuotaUsage {
                subject: "prop_test".to_string(),
                subject_type: QuotaSubjectType::User,
                used_bytes: used.saturating_add(1),
                used_files: 0,
                iops_current: 0,
            };
            registry.update_usage(usage);
            
            if used < limit_val {
                assert!(registry.check_quota("prop_test").is_ok());
            }
        }
    }
}
